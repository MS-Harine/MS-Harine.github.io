[
  
  {
    "title": "Boost.Interprocess - 빠른 가이드 (Quick Guide for Impatient)",
    "url": "/posts/QuickGuide/",
    "categories": "Boost",
    "tags": "c++, boost",
    "date": "2025-11-25 23:00:00 +0900",
    "content": "개인 공부를 위해 번역한 내용으로, 정확하지 않을 수 있습니다.  Boost 1.86.0 버전을 기반으로 합니다.  자세한 정보는 공식 사이트를 참고해주세요   공유 메모리를 이름 없는 메모리 블럭 풀로 사용하기     공유 메모리의 일부를 할당하고,   메세지를 해당 버퍼에 복사한 후   다른 프로세스에게 해당 공유 메모리의 오프셋을 전송하면 됩니다.   예제를 보시죠  #include &lt;boost/interprocess/managed_shared_memory.hpp&gt; #include &lt;cstdlib&gt; // std::system #include &lt;sstream&gt;  int main (int argc, char *argv[]) {     using namespace boost::interprocess;     if (argc == 1) {  // Parent process         // Remove shared memory on construction and destruction         // 관련 내용은 RAII (Resource Acquisition Is Initialization) 디자인 패턴 참고         struct shm_remove         {             shm_remove() {  shared_memory_object::remove(\"MySharedMemory\"); }             ~shm_remove(){  shared_memory_object::remove(\"MySharedMemory\"); }         } remover;          // Create a managed shared memory segment         managed_shared_memory segment(create_only, \"MySharedMemory\", 65536);          // Allocate a portion of the segment (raw memory)         managed_shared_memory::size_type free_memory = segment.get_free_memory();         void *shptr = segment.allocate(1024/*bytes to allocate*/);          // Check invariant         if (free_memory &lt;= segment.get_free_memory())             return 1;          // An handle from the base address can identify any byte of the shared         // memory segment even if it is mapped in different base addresses         managed_shared_memory::handle_t handle = segment.get_handle_from_address(shptr);         std::stringstream s;         s &lt;&lt; argv[0] &lt;&lt; \" \" &lt;&lt; handle;         s &lt;&lt; std::ends;          // Launch child process         if (0 != std::system(s.str().c_str()))             return 1;          // Check memory has been freed         if (free_memory != segment.get_free_memory())             return 1;     }     else{         // Open managed segment         managed_shared_memory segment(open_only, \"MySharedMemory\");          // An handle from the base address can identify any byte of the shared         // memory segment even if it is mapped in different base addresses         managed_shared_memory::handle_t handle = 0;          // Obtain handle value         std::stringstream s;         s &lt;&lt; argv[1];         s &gt;&gt; handle;          // Get buffer local address from handle         void *msg = segment.get_address_from_handle(handle);          // Deallocate previously allocated memory         segment.deallocate(msg);     }     return 0; }   이름 있는 공유 메모리 객체 생성하기  이름이 있는 공유 메모리 객체를 생성하여 다른 프로세스가 찾고, 사용하며, 쓸모없을 때 삭제할 수 있습니다.  예제 :  #include &lt;boost/interprocess/managed_shared_memory.hpp&gt; #include &lt;cstdlib&gt; // std::system #include &lt;cstddef&gt; #include &lt;cassert&gt; #include &lt;utility&gt;  int main(int argc, char *argv[]) {     using namespace boost::interprocess;     typedef std::pair&lt;double, int&gt; MyType;      if (argc == 1) {  // Parent process         // Remove shared memory on construction and destruction         struct shm_remove         {             shm_remove() { shared_memory_object::remove(\"MySharedMemory\"); }             ~shm_remove(){ shared_memory_object::remove(\"MySharedMemory\"); }         } remover;          // Construct managed shared memory         managed_shared_memory segment(create_only, \"MySharedMemory\", 65536);          // Create an object of MyType initialized to {0.0, 0}         MyType *instance = segment.construct&lt;MyType&gt;             (\"MyType instance\")  // name of the object             (0.0, 0);            // ctor first argument          // Create an array of 10 elements of MyType initialized to {0.0, 0}         MyType *array = segment.construct&lt;MyType&gt;             (\"MyType array\")     // name of the object             [10]                 // number of elements             (0.0, 0);            // Same two ctor arguments for all objects          // Create an array of 3 elements of MyType initializing each one         // to a different value {0.0, 0}, {1.0, 1}, {2.0, 2}...         float float_initializer[3] = { 0.0, 1.0, 2.0 };         int   int_initializer[3]   = { 0, 1, 2 };          MyType *array_it = segment.construct_it&lt;MyType&gt;             (\"MyType array from it\")   // name of the object             [3]                        // number of elements             ( &amp;float_initializer[0]    // Iterator for the 1st ctor argument             , &amp;int_initializer[0]);    // Iterator for the 2nd ctor argument          // Launch child process         std::string s(argv[0]);         s += \" child \";         if (0 != std::system(s.c_str()))             return 1;          // Check child has destroyed all objects         if (segment.find&lt;MyType&gt;(\"MyType array\").first ||             segment.find&lt;MyType&gt;(\"MyType instance\").first ||             segment.find&lt;MyType&gt;(\"MyType array from it\").first)             return 1;     }     else{         // Open managed shared memory         managed_shared_memory segment(open_only, \"MySharedMemory\");          std::pair&lt;MyType*, managed_shared_memory::size_type&gt; res;          // Find the array         res = segment.find&lt;MyType&gt; (\"MyType array\");         // Length should be 10         if (res.second != 10)             return 1;          // Find the object         res = segment.find&lt;MyType&gt; (\"MyType instance\");         // Length should be 1         if (res.second != 1)             return 1;          // Find the array constructed from iterators         res = segment.find&lt;MyType&gt; (\"MyType array from it\");         // Length should be 3         if (res.second != 3)             return 1;          // We're done, delete all the objects         segment.destroy&lt;MyType&gt;(\"MyType array\");         segment.destroy&lt;MyType&gt;(\"MyType instance\");         segment.destroy&lt;MyType&gt;(\"MyType array from it\");     }     return 0; }   공유 메모리에 Offset smart pointer 사용하기  Boost.Interprocess는 offset pointer 자체의 주소와 가리키는 객체의 주소값의 거리를 저장하는 offset pointer로써 offset_ptr 스마트 포인터 종류를 제공합니다. offset_ptr이 공유 메모리 세그먼트에 있을 때 같은 공유 메모리 세그먼트에 있는 객체를 안전하게 가르킬 수 있습니다. 해당 세그먼트가 다른 프로세스의 다른 base address에 매칭되더라도 말이죠.  이건 객체들을 포인터 멤버들과 함께 공유 메모리에 위치시킬 수 있도록 합니다. 아래는 공유 메모리에서 Linked list를 만든 예제입니다.  #include &lt;boost/interprocess/managed_shared_memory.hpp&gt; #include &lt;boost/interprocess/offset_ptr.hpp&gt;  using namespace boost::interprocess;  // Shared memory linked list node struct list_node {     offset_ptr&lt;list_node&gt; next;     int                   value; };  int main() {     // Remove shared memory on construction and destruction     struct shm_remove     {         shm_remove() { shared_memory_object::remove(\"MySharedMemory\"); }         ~shm_remove(){ shared_memory_object::remove(\"MySharedMemory\"); }     } remover;      // Create shared memory     managed_shared_memory segment(create_only,                                   \"MySharedMemory\",  // segment name                                   65536);      // Create linked list with 10 nodes in shared memory     offset_ptr&lt;list_node&gt; prev = 0, current, first;      int i;     for (i = 0; i &lt; 10; ++i, prev = current) {         current = static_cast&lt;list_node*&gt;(segment.allocate(sizeof(list_node)));         current-&gt;value = i;         current-&gt;next  = 0;          if(!prev)             first = current;         else             prev-&gt;next = current;     }      // Communicate list to other processes     // ...      // When done, destroy list     for (current = first; current; /**/) {         prev = current;         current = current-&gt;next;         segment.deallocate(prev.get());     }     return 0; }   기본적인 데이터 구조를 돕기 위해 Boost.Interprocess는 vector, list, map등과 같은 컨테이너를 지원하므로, std 컨테이너같은 manual data structure를 피할 수 있습니다.  공유 메모리에 벡터 생성하기 Boost.Interprocess는 공유 메모리와 메모리 맵 파일에 복잡한 객체를 생성할 수 있습니다. 예시로, STL같은 컨테이너를 공유 메모리에 구성할 수 있습니다. 이를 위해 특별한 (managed) 공유 메모리를 생성하고, Boost.Interprocess allocator를 선언한 후 벡터를 공유 메모리에 구성하기만 하면 됩니다.  복잡한 구조를 공유 메모리에 올릴 수 있는 클래스를 boost::interprocess::managed_shared_memory라고 하며, 사용하기 쉽습니다. Argument 없이 아래 예제를 실행해보세요.  #include &lt;boost/interprocess/managed_shared_memory.hpp&gt; #include &lt;boost/interprocess/containers/vector.hpp&gt; #include &lt;boost/interprocess/allocators/allocator.hpp&gt; #include &lt;string&gt; #include &lt;cstdlib&gt; //std::system  using namespace boost::interprocess;  // Define an STL compatible allocator of ints that allocates from the managed_shared_memory. // This allocator will allow placing containers in the segment typedef allocator&lt;int, managed_shared_memory::segment_manager&gt;  ShmemAllocator;  // Alias a vector that uses the previous STL-like allocator so that allocates // its values from the segment typedef vector&lt;int, ShmemAllocator&gt; MyVector;  // Main function. For parent process argc == 1, for child process argc == 2 int main(int argc, char *argv[]) {     if (argc == 1) { // Parent process         // Remove shared memory on construction and destruction         struct shm_remove         {             shm_remove() { shared_memory_object::remove(\"MySharedMemory\"); }             ~shm_remove(){ shared_memory_object::remove(\"MySharedMemory\"); }         } remover;          // Create a new segment with given name and size         managed_shared_memory segment(create_only, \"MySharedMemory\", 65536);          // Initialize shared memory STL-compatible allocator         const ShmemAllocator alloc_inst(segment.get_segment_manager());          // Construct a vector named \"MyVector\" in shared memory with argument alloc_inst         MyVector *myvector = segment.construct&lt;MyVector&gt;(\"MyVector\")(alloc_inst);          for (int i = 0; i &lt; 100; ++i)  // Insert data in the vector             myvector-&gt;push_back(i);          // Launch child process         std::string s(argv[0]);         s += \" child \";         if (0 != std::system(s.c_str()))             return 1;          // Check child has destroyed the vector         if (segment.find&lt;MyVector&gt;(\"MyVector\").first)             return 1;     }     else { // Child process         // Open the managed segment         managed_shared_memory segment(open_only, \"MySharedMemory\");          // Find the vector using the c-string name         MyVector *myvector = segment.find&lt;MyVector&gt;(\"MyVector\").first;          // Use vector in reverse order         std::sort(myvector-&gt;rbegin(), myvector-&gt;rend());          // When done, destroy the vector from the segment         segment.destroy&lt;MyVector&gt;(\"MyVector\");     }      return 0; }   부모 프로세스는 많은 복잡한 데이터를 이름으로 쉽게 구성할 수 있는 특별한 공유 메모리를 생성합니다. 부모 프로세스는 동일한 프로그램을 argument와 함께 실행하고, 자식 프로세스는 공유 메모리를 열고 벡터를 사용하며, 메모리를 지웁니다.  공유 메모리에 map 만들기  Boost.Interprocess는 벡터처럼 공유 메모리와 메모리 맵 파일에 map을 만들 수 있습니다. 유일한 차이점은 standard associative 컨테이너와 마찬가지로 Boost.Interprocess의 map도 생성자에서 allocator가 전달될 때 비교 함수가 함께 전달되어야 한다는 것입니다.  #include &lt;boost/interprocess/managed_shared_memory.hpp&gt; #include &lt;boost/interprocess/containers/map.hpp&gt; #include &lt;boost/interprocess/allocators/allocator.hpp&gt; #include &lt;functional&gt; #include &lt;utility&gt;  int main () {     using namespace boost::interprocess;      // Remove shared memory on construction and destruction     struct shm_remove     {         shm_remove() { shared_memory_object::remove(\"MySharedMemory\"); }         ~shm_remove(){ shared_memory_object::remove(\"MySharedMemory\"); }     } remover;      // Shared memory front-end that is able to construct objects     // associated with a c-string. Erase previous shared memory with the name     // to be used and create the memory segment at the specified address and initialize resources     managed_shared_memory segment         (create_only         ,\"MySharedMemory\" //segment name         ,65536);          //segment size in bytes      // Note that map&lt;Key, MappedType&gt;'s value_type is std::pair&lt;const Key, MappedType&gt;,     // so the allocator must allocate that pair.     typedef int    KeyType;     typedef float  MappedType;     typedef std::pair&lt;const int, float&gt; ValueType;      // Alias an STL compatible allocator of for the map.     // This allocator will allow to place containers     // in managed shared memory segments     typedef allocator&lt;ValueType, managed_shared_memory::segment_manager&gt; ShmemAllocator;      // Alias a map of ints that uses the previous STL-like allocator.     // Note that the third parameter argument is the ordering function     // of the map, just like with std::map, used to compare the keys.     typedef map&lt;KeyType, MappedType, std::less&lt;KeyType&gt;, ShmemAllocator&gt; MyMap;      // Initialize the shared memory STL-compatible allocator     ShmemAllocator alloc_inst(segment.get_segment_manager());      // Construct a shared memory map.     // Note that the first parameter is the comparison function,     // and the second one the allocator.     // This the same signature as std::map's constructor taking an allocator     MyMap *mymap = segment.construct&lt;MyMap&gt;(\"MyMap\")   // object name                                     (std::less&lt;int&gt;()  // first  ctor parameter                                     , alloc_inst);     // second ctor parameter      // Insert data in the map     for (int i = 0; i &lt; 100; ++i) {         mymap-&gt;insert(std::pair&lt;const int, float&gt;(i, (float)i));     }      return 0; }   더 많은 예제(컨테이너에 컨테이너가 들어간 버전 등)는 이 섹션을 참고하세요"
  },
  
  {
    "title": "Boost.Interprocess - 서론 (Introduction)",
    "url": "/posts/Introduction/",
    "categories": "Boost",
    "tags": "c++, boost",
    "date": "2025-11-25 23:00:00 +0900",
    "content": "개인 공부를 위해 번역한 내용으로, 정확하지 않을 수 있습니다.  Boost 1.86.0 버전을 기반으로 합니다.  자세한 정보는 공식 사이트를 참고해주세요   Introduction Boost.Interprocess는 보편적인 프로세스간 통신과 (interprocess communication) 동기화 메커니즘의 (synchronization mechanism) 사용을 단순화 하며, 아래 내용들을 제공합니다.     공유 메모리 (Shared memory)   메모리 맵 파일 (Memory-mapped file)   세마포어 (Semaphore), 뮤텍스 (Mutex), 조건변수 (Conditional variable), 업그레이드 가능한 뮤텍스 (Upgradable Mutex) 들을 공유 메모리와 메모리 맵 파일에 배치할 수 있음   UNIX의 sem_open, Windows의 CreateSemaphore API와 같은 동기화 객체에 이름 설정   파일 잠금 (File locking)   Relative pointer   메세지 큐 (Message queue)   또한 Boost.Interprocess는 공유 메모리 또는 메모리 맵 파일의 일부를 동적으로 할당하는 높은 수준의 interprocess 메커니즘을 제공합니다. (일반적으로, 고정된 크기의 메모리 세그먼트 일부를 할당합니다.) Boost.Interprocess는 이러한 메커니즘을 사용하여 STL과 같은 컨테이너를 포함한 C++ 객체들을 공유 메모리와 메모리 맵 파일에 구성(construct)할 수 있는 유용한 툴을 제공합니다.     공유 메모리 / 메모리 맵 파일에 이름이 있는 객체와 이름이 없는 객체(anonymous object)를 동적으로 생성   공유 메모리 / 메모리 맵 파일과 호환되는 STL같은 컨테이너   공유 메모리 / 메모리 맵 파일에 사용할 수 있는 다양한 메모리 할당 패턴이 구현된 STL같은 allocator (예: Pooling)   Building Boost.Interprocess  Boost.Interprocess는 header only 라이브러리이기 때문에 빌드할 필요가 없습니다. 컴파일러 include path에 Boost header 디렉토리를 추가하세요.  Boost.Interprocess는 별도의 컴파일이 필요한 Boost.DateTime에 의존합니다. 하지만 Boost.Interprocess의 하위 집합(subset)은 별도 컴파일을 요구하지 않으므로, BOOST_DATE_TIME_NO_LIB를 define 함으로써 Boost.DateTime을 자동으로 링크하지 않도록 할 수 있습니다.  Boost.Interprocess는 POSIX 시스템에서 뮤텍스, 조건변수 클래스 등을 구현하기 위해 pthread system call을 사용합니다. 어떤 운영체제에서는 이런 POSIX 호출을 분리된 라이브러리에서 구현되어 있기 때문에 컴파일러가 자동으로 링크하지 못하기도 합니다. 예를 들어, 몇몇 리눅스 시스템에서는 POSIX pthread 함수들이 librt.a 라이브러리에 구현되어있기 때문에 Boost.Interprocess를 사용하기 위해서는 Executable 또는 Shared Library를 링킹할 때 추가해줘야 할 수도 있습니다. 만약 pthread 함수에 관련된 링킹 에러가 발생하면 당신의 시스템의 문서를 확인해서 어느 라이브러리에 해당 함수가 구현되어있는지 확인해주세요.  Tested compilers  Boost.Interprocess는 아래 플랫폼/컴파일러에서 테스트 되었습니다.     Visual C++ &gt;= 7.1   GCC &gt;= 4.1      Warning  GCC &lt; 4.3 및 MSVC &lt; 9.0은 deprecated 되었고, 다음 버전에서 삭제될 예정입니다."
  }
  
]

